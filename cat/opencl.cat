OpenCL
(* OpenCL Memory Model *)

(*
* This model is based on:
* https://github.com/herd/herdtools7/blob/master/herd-www/cat_includes/opencl_base.cat
* https://github.com/herd/herdtools7/blob/master/herd-www/cat_includes/opencl.cat
*)

// Base relations:
// int: same work-item
// swg: same work-group
// sdv: same device
// syncbar: same barrier id

// Tags:
// WI: work-item scope
// WG: work-group scope
// DV: device scope
// ALL: all-svm-devices scope
// GLOBAL: global memory
// LOCAL: local memory
// EF: entry fence of barrier
// XF: exit fence of barrier

let symm(r) = r | r^-1

(* Inclusive scopes *)
let swi = int & (NA * NA)
let incl = (swi & (WI * WI)) |
    (swg & (WG * WG)) |
    (sdv & (DV * DV)) |
    (ALL * ALL)

(*******************)
(* Synchronisation *)
(*******************)

let Acq = (ACQ | SC | ACQ_REL) & (R | F | RMW)
let Rel = (REL | SC | ACQ_REL) & (W | F | RMW)

(* Release sequence *)
let rs = (_ * RMW) | int
let max_co = co? & rs & ~((co & ~rs) ; co)

(* Including release-acquire fences *)
let relf = [Rel]; ([F]; po)?; [A & W]
let acqf = [A & R]; (po; [F])?; [Acq]

(* Release-acquire synchronisation *)
let ra_sw(r) = incl & ~int & ([r]; relf; max_co; [r]; rf; acqf; [r])

(* Barrier synchronisation *)
// in OpenCL a barrier results in two fence operations: entry and exit fences:
// https://registry.khronos.org/OpenCL/specs/3.0-unified/html/OpenCL_API.html#_work_group_functions
let bar_sw(r) = (EF * XF) & syncbar & ~int & swg & (r * r)

(* Synchronisation on a region *)
let region_sw(r) = ra_sw(r) | bar_sw(r)

(* Allowed to synchronise on the other region *)
let scf = (SC * SC) | ((GLOBAL & LOCAL & F) * (GLOBAL & LOCAL & F))

(* Global and local synchronises-with *)
let gsw = region_sw(GLOBAL) | (scf & region_sw(LOCAL))
let lsw = region_sw(LOCAL) | (scf & region_sw(GLOBAL))

(******************)
(* Happens-before *)
(******************)

(* Global and local happens-before *)
let ghb = (((GLOBAL * GLOBAL) & (po | (IW * ~IW))) | gsw)+
let lhb = (((LOCAL * LOCAL) & (po | (IW * ~IW))) | lsw)+

acyclic ghb as global_hb_acyclic
acyclic lhb as local_hb_acyclic

(* Per-location happens-before *)
let ghbl = ghb & loc
let lhbl = lhb & loc

(*************)
(* Coherence *)
(*************)

let coh(hb) = (rf^-1)?; co; rf?; hb
irreflexive coh(ghb) as global_coherence
irreflexive coh(lhb) as local_coherence

(************************)
(* Consistency of reads *)
(************************)

(* Visible side effects *)
let vse(hbl) = (W * R) & hbl & ~(hbl; [W]; hbl)
let gvse = [GLOBAL]; vse(ghbl)
let lvse = [LOCAL]; vse(lhbl)

(* A non-atomic load can only read from a store that is visible. *)
irreflexive rf; [NA & GLOBAL]; ~(gvse^-1) as global_nonatomic_rf_consistent
irreflexive rf; [NA & LOCAL]; ~(lvse^-1) as local_nonatomic_rf_consistent

(* An atomic load can only read from a store that already happened. *)
irreflexive (ghb | lhb); rf; [A] as atomic_rf_consistent

(* Consistency of RMWs *)
irreflexive rf | (fr;co) | (co;rf) as rmw_consistent

(**************************)
(* Sequential consistency *)
(**************************)

(* ifexists(s) = { 0    if s is empty
                 { unv  otherwise     *)
let unv = ~0
let ifexists(s) = unv; [s]; unv


let sc1 = rf^-1; [SC]; co
let sc2 = [F]; po; co; po; [F]
let sc3 = [F]; po; fr; po; [F]
let sc4 =          fr; po; [F]
let sc5 = [F]; po; fr

let scp = (SC * SC) & (ghb | lhb | co | sc1 | sc2 | sc3 | sc4 | sc5)

let sc6 = rf^-1; (ghb | lhb); [W]

(* BEGIN PARTIAL SC STUFF *)
let scp_prime = scp & sc6
acyclic scp_prime & ifexists(SC & ~ALL) as s_exists
(* END PARTIAL SC STUFF *)

(***************)
(*    Races    *)
(***************)

let conflict = (((W * _) | (_ * W)) \ ((IW * _) | (_ * IW))) & loc

let dr = conflict & ~symm(ghb | lhb) & ~incl
flag ~empty dr as data_race

let ur = (swi & conflict & ~symm(po)) \ id
flag ~empty ur as unsequenced_race

let bsw = bar_sw(GLOBAL) | bar_sw(LOCAL)
// let bd = [EF] & ((~int & swg & ~(bar_sw(GLOBAL) | bar_sw(LOCAL))); [_]) // opencl_total
let bd = [EF] & (~int & swg) \ bsw
flag ~empty bd as barrier_divergence
