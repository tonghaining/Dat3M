OpenCL
// Modified from: https://github.com/herd/herdtools7/blob/master/herd-www/cat_includes/opencl_base.cat

// Base relations:
// swi: same work-item
// swg: same work-group
// sdev: same device

// Tags:
// WI: work-item
// WG: work-group
// DEV: device
// ALL: all-svm-devices
// GLOBAL: global
// LOCAL: local

(* Inclusive scopes *)
let incl =
    (swi & (WI * WI)) |
    (swg & (WG * WG)) |
    (sdev & (DEV * DEV)) |
    (ALL * ALL)

(*******************)
(* Synchronisation *)
(*******************)

let acq_op = (ACQ | SC | ACQ_REL) & (R | F | rmw)
let rel_op = (REL | SC | ACQ_REL) & (W | F | rmw)

(* Release sequence *)
let rs = (_ * rmw) | swi
let max_co = co? & rs & ~((co & ~rs) ; co)

(* Including release-acquire fences *)
let relf = [rel_op]; ([F]; po)?; [A & W]
let acqf = [A & R]; (po; [F])?; [acq_op]

(* Release-acquire synchronisation *)
let ra_sw_g = incl & ~swi & ([GLOBAL]; relf; max_co; [GLOBAL]; rf; acqf; [GLOBAL])
let ra_sw_l = incl & ~swi & ([LOCAL]; relf; max_co; [LOCAL]; rf; acqf; [LOCAL])

(* Barrier synchronisation *)
let bar_sw_g = (entry_fence * exit_fence) & same_B & ~swi & wg & (GLOBAL * GLOBAL
let bar_sw_l = (entry_fence * exit_fence) & same_B & ~swi & wg & (LOCAL * LOCAL)

(* Synchronisation on a region *)
let region_sw_g = ra_sw_g | bar_sw_g
let region_sw_l = ra_sw_l | bar_sw_l

(* Allowed to synchronise on the other region *)
let scf = (SC * SC) | ((GLOBAL & LOCAL & F) * (GLOBAL & LOCAL & F))

(* Global and local synchronises-with *)
let gsw = region_sw_g | (scf & region_sw_l)
let lsw = region_sw_l | (scf & region_sw_g)

(******************)
(* Happens-before *)
(******************)

(* Global and local happens-before *)
let ghb = (((GLOBAL * GLOBAL) & (po | (I * !I))) | gsw)+
let lhb = (((LOCAL * LOCAL) & (po | (I * !I))) | lsw)+

acyclic ghb as global_hb_acyclic
acyclic lhb as local_hb_acyclic

(* Per-location happens-before *)
let ghbl = ghb & loc
let lhbl = lhb & loc

(*************)
(* Coherence *)
(*************)

let coh_hb_g = (rf^-1)?; co; rf?; ghbl
let coh_hb_l = (rf^-1)?; co; rf?; lhbl
irreflexive coh_hb_g as global_coherence
irreflexive coh_hb_l as local_coherence

(************************)
(* Consistency of reads *)
(************************)

(* Visible side effects *)
let vse(hbl) = (W * R) & hbl & ~(hbl; [W]; hbl)
let vse_hbl_g = (W * R) & ghbl & ~(ghbl; [W]; ghbl)
let vse_hbl_l = (W * R) & lhbl & ~(lhbl; [W]; lhbl)
let gvse = [GLOBAL]; vse_hbl_g
let lvse = [LOCAL]; vse_hbl_l

(* A non-atomic load can only read from a store that is visible. *)
irreflexive rf; [nonatomicloc & GLOBAL]; ~(gvse^-1) as global_nonatomic_rf_consistent
irreflexive rf; [nonatomicloc & LOCAL]; ~(lvse^-1) as local_nonatomic_rf_consistent

(* An atomic load can only read from a store that already happened. *)
irreflexive (ghb | lhb); rf; [A] as atomic_rf_consistent

(* Consistency of RMWs *)
irreflexive rf | (fr;co) | (co;rf) as rmw_consistent

(**************************)
(* Sequential consistency *)
(**************************)

let sc1 = rf^-1; [SC]; co
let sc2 = [F]; po; co; po; [F]
let sc3 = [F]; po; fr; po; [F]
let sc4 =          fr; po; [F]
let sc5 = [F]; po; fr

let scp = (SC * SC) & (ghb | lhb | co | sc1 | sc2 | sc3 | sc4 | sc5)

let sc6 = rf^-1; (ghb | lhb); [W]